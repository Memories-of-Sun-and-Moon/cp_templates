---
data:
  _extendedDependsOn:
  - icon: ':heavy_check_mark:'
    path: geometry/util.hpp
    title: "\u5E7E\u4F55\u30E9\u30A4\u30D6\u30E9\u30EA"
  - icon: ':heavy_check_mark:'
    path: template/template.hpp
    title: template/template.hpp
  _extendedRequiredBy: []
  _extendedVerifiedWith: []
  _isVerificationFailed: false
  _pathExtension: cpp
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    '*NOT_SPECIAL_COMMENTS*': ''
    ERROR: 1e-8
    PROBLEM: https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_2_D
    links:
    - https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_2_D
  bundledCode: "#line 1 \"verify/aoj/cgl/2_D.test.cpp\"\n#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_2_D\"\
    \n#define ERROR \"1e-8\"\n\n#line 1 \"template/template.hpp\"\n# include <bits/stdc++.h>\n\
    using namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\
    const double pi = acos(-1);\ntemplate<class T>constexpr T inf() { return ::std::numeric_limits<T>::max();\
    \ }\ntemplate<class T>constexpr T hinf() { return inf<T>() / 2; }\ntemplate <typename\
    \ T_char>T_char TL(T_char cX) { return tolower(cX); }\ntemplate <typename T_char>T_char\
    \ TU(T_char cX) { return toupper(cX); }\ntemplate<class T> bool chmin(T& a,T b)\
    \ { if(a > b){a = b; return true;} return false; }\ntemplate<class T> bool chmax(T&\
    \ a,T b) { if(a < b){a = b; return true;} return false; }\nint popcnt(unsigned\
    \ long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++;\
    \ return cnt; }\nint d_sum(ll n) { int ret = 0; while (n > 0) { ret += n % 10;\
    \ n /= 10; }return ret; }\nint d_cnt(ll n) { int ret = 0; while (n > 0) { ret++;\
    \ n /= 10; }return ret; }\nll gcd(ll a, ll b) { if (b == 0)return a; return gcd(b,\
    \ a%b); };\nll lcm(ll a, ll b) { ll g = gcd(a, b); return a / g*b; };\nll MOD(ll\
    \ x, ll m){return (x%m+m)%m; }\nll FLOOR(ll x, ll m) {ll r = (x%m+m)%m; return\
    \ (x-r)/m; }\ntemplate<class T> using dijk = priority_queue<T, vector<T>, greater<T>>;\n\
    # define all(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)\
    \        (wpwpw).erase(unique(all((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)\
    \         transform(all((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)\
    \         transform(all((rprpr)),(rprpr).begin(),TU<char>)\n# define rep(i,upupu)\
    \         for(ll i = 0, i##_len = (upupu);(i) < (i##_len);(i)++)\n# define reps(i,opopo)\
    \        for(ll i = 1, i##_len = (opopo);(i) <= (i##_len);(i)++)\n# define len(x)\
    \                ((ll)(x).size())\n# define bit(n)               (1LL << (n))\n\
    # define pb push_back\n# define eb emplace_back\n# define exists(c, e)       \
    \  ((c).find(e) != (c).end())\n\nstruct INIT{\n\tINIT(){\n\t\tstd::ios::sync_with_stdio(false);\n\
    \t\tstd::cin.tie(0);\n\t\tcout << fixed << setprecision(20);\n\t}\n}INIT;\n\n\
    namespace mmrz {\n\tvoid solve();\n}\n\nint main(){\n\tmmrz::solve();\n}\n#line\
    \ 1 \"geometry/util.hpp\"\n\nusing DOUBLE = long double;\n\nconstexpr DOUBLE EPS\
    \ = 1e-9;\n\n//a > 0\u306A\u3089\u3070+1, a == 0\u306A\u3089\u30700, a < 0\u306A\
    \u3089\u3070-1\u3000\u3092\u8FD4\u3059\u3002\u3000\u57FA\u672C\u7684\u306BEPS\u8FBC\
    \u307F\u306E\u8A55\u4FA1\u306F\u3053\u308C\u3067\u884C\u3046\u3002\n//\u4E0D\u7B49\
    \u5F0F\u306F\u3001\u52A0\u6E1B\u7B97\u306B\u76F4\u3057\u3066\u3053\u308C\u306B\
    \u9069\u7528\u3059\u308B\u3002\nint sgn(const double a) {\n    return (a < -EPS\
    \ ? -1 : (a > EPS ? +1 : 0));\n}\n\nstruct point {\n\tDOUBLE x, y;\n\n\tpoint(DOUBLE\
    \ _x = 0, DOUBLE _y = 0): x(_x), y(_y) {}\n\n\tpoint operator+(point p){ return\
    \ point(x+p.x, y+p.y); }\n\tpoint operator+(const point &p) const { return point(x+p.x,\
    \ y+p.y); }\n\tpoint operator-(point p){ return point(x-p.x, y-p.y); }\n\tpoint\
    \ operator-(const point &p) const { return point(x-p.x, y-p.y); }\n\tpoint operator*(DOUBLE\
    \ a) {return point(x*a, y*a); }\n\tpoint operator/(DOUBLE a) {return point(x/a,\
    \ y/a); }\n\t\n\n\tDOUBLE abs() const {return sqrtl(norm()); }\n\tDOUBLE norm()\
    \ const {return x*x + y*y; }\n\n\tpoint conjuacy() const {return point(x, -y);\
    \ }\n\n\tpoint operator*(const point &p) const { return point(x*p.x - y*p.y, x*p.y\
    \ + y*p.x); }\n\tpoint operator/(const point &p) const { return (*this * p.conjuacy())\
    \ / p.norm(); }\n\n\tbool operator<(const point &p) const {\n\t\treturn (not (fabs(x-p.x)\
    \ < EPS)? x<p.x : y<p.y);\n\t}\n\n\tbool operator==(const point &p) const {\n\t\
    \treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n};\nistream& operator >>\
    \ (istream &is, point &p){return is >> p.x >> p.y;}\nostream& operator << (ostream\
    \ &os, const point &p){return os << p.x << \" \" << p.y;}\n\nusing polygon = vector<point>;\n\
    \nstruct segment {point p1, p2; };\ntypedef segment line;\nistream& operator >>\
    \ (istream &is, segment &s){return is >> s.p1 >> s.p2;}\nostream& operator <<\
    \ (ostream &os, const segment &s){return os << s.p1 << \" \" << s.p2;}\n\n\nstruct\
    \ circle {\n\tpoint c;\n\tDOUBLE r;\n\tcircle(point _c = point(), DOUBLE _r =\
    \ 0.0): c(_c), r(_r) {}\n};\nistream& operator >> (istream &is, circle &s){return\
    \ is >> s.c >> s.r;}\nostream& operator << (ostream &os, const circle &s){return\
    \ os << s.c << \" \" << s.r;}\n\n\nDOUBLE dot(point a, point b) {\n\treturn a.x*b.x\
    \ + a.y*b.y;\n}\n\nDOUBLE cross(point a, point b) {\n\treturn a.x*b.y - a.y*b.x;\n\
    }\n\nconstexpr int COUNTER_CLOCKWISE = 1;\nconstexpr int CLOCKWISE = -1;\nconstexpr\
    \ int ONLINE_BACK = 2;\nconstexpr int ONLINE_FRONT = -2;\nconstexpr int ON_SEGMENT\
    \ = 0;\n\nint ccw(point p0, point p1, point p2) {\n\tpoint a = p1 - p0;\n\tpoint\
    \ b = p2 - p0;\n\t\n\tif(p0 == p1)return ON_SEGMENT;\n\tif(p0 == p2)return ON_SEGMENT;\n\
    \tif(p1 == p2)return ON_SEGMENT;\n\t\n\tif(cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\
    \tif(cross(a, b) < -EPS)return CLOCKWISE;\n\tif(dot(a, b) < -EPS)return ONLINE_BACK;\n\
    \tif(a.norm() < b.norm())return ONLINE_FRONT;\n\t\n\treturn ON_SEGMENT;\n}\n\n\
    bool intersect(point p1, point p2, point p3, point p4) {\n\treturn (ccw(p1, p2,\
    \ p3)*ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\n\nbool\
    \ intersect(segment s1, segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1,\
    \ s2.p2);\n}\n\n// \u5171\u901A\u63A5\u7DDA\u306E\u6570\u3092\u8FD4\u3059\nint\
    \ intersect(const circle &c1, const circle &c2) {\n\tDOUBLE r1 = c1.r + c2.r;\n\
    \tDOUBLE r2 = abs(c1.r - c2.r);\n\tDOUBLE d = (c2.c-c1.c).abs();\n\tif(sgn(d-r1)\
    \ == 1)return 4;\n\tif(sgn(d-r1) == 0)return 3;\n\tif(sgn(r2-d) == 0)return 1;\n\
    \tif(sgn(r2-d) == 1)return 0;\n\treturn 2;\n}\n\npoint project(line &s, point\
    \ &p) {\n\tpoint base = s.p2 - s.p1;\n\tDOUBLE r = dot(p-s.p1, base) / base.norm();\n\
    \treturn s.p1 + base*r;\n}\n\npoint reflect(line s, point p) {\n\treturn p + (project(s,\
    \ p) - p) * 2.0;\n}\n\nDOUBLE get_distance(point &a, point &b){\n\treturn (a-b).abs();\n\
    }\n\n// line, point\nDOUBLE get_distance_lp(line &l, point &p){\n\treturn abs(cross(l.p2-l.p1,\
    \ p-l.p1) / (l.p2-l.p1).abs());\n}\n// segment, point\nDOUBLE get_distance_sp(segment\
    \ &s, point &p){\n\tif(dot(s.p2-s.p1, p-s.p1) < 0.0)return (p-s.p1).abs();\n\t\
    if(dot(s.p1-s.p2, p-s.p2) < 0.0)return (p-s.p2).abs();\n\treturn get_distance_lp(s,\
    \ p);\n}\n\nDOUBLE get_distance(segment &s1, segment &s2){\n\tif(intersect(s1,\
    \ s2))return 0.0;\n\treturn min({get_distance_sp(s1, s2.p1), get_distance_sp(s1,\
    \ s2.p2), get_distance_sp(s2, s1.p1), get_distance_sp(s2, s1.p2)});\n}\n\nvector<point>\
    \ get_crosspoint(line &l, line &m){\n\tvector<point> res;\n\tDOUBLE d = cross(m.p2-m.p1,\
    \ l.p2-l.p1);\n\tif(abs(d) < EPS)return vector<point>();\n\tDOUBLE t = cross(m.p2-m.p1,\
    \ m.p2-l.p1) / d;\n\tpoint r = l.p1 + (l.p2-l.p1) * t;\n\tres.push_back(r);\n\t\
    return res;\n}\n\npair<point, point> get_crosspoints(circle &c, line &l){\n\t\
    point pr = project(l, c.c);\n\tpoint e = (l.p2-l.p1)/(l.p2-l.p1).abs();\n\tDOUBLE\
    \ base = sqrt(max<DOUBLE>(0.0, c.r*c.r - (pr-c.c).norm()));\n\treturn {pr+e*base,\
    \ pr-e*base};\n}\n\npoint polar (DOUBLE a, DOUBLE r){\n\treturn point(cos(r)*a,\
    \ sin(r)*a);\n}\n\npair<point, point> get_crosspoints(const circle &c1, const\
    \ circle &c2){\n\tDOUBLE d = (c1.c-c2.c).abs();\n\tDOUBLE a = acos((c1.r*c1.r\
    \ + d*d - c2.r*c2.r) / (2*c1.r*d));\n\tDOUBLE t = atan2((c2.c-c1.c).y, (c2.c-c1.c).x);\n\
    \treturn {c1.c+polar(c1.r, t+a), c1.c+polar(c1.r, t-a)};\n}\n\nDOUBLE deg_to_rad(const\
    \ DOUBLE &deg) {return deg*pi / 180.0; };\n\n//\u76F4\u4EA4\u5224\u5B9A\nbool\
    \ is_orthogonal(point a, point b){\n    return sgn(dot(a, b)) == 0;\n}\nbool is_orthogonal(segment\
    \ s1, segment s2){\n    return sgn(dot(s1.p2 - s1.p1, s2.p2 - s2.p1)) == 0;\n\
    }\n\n//\u4E26\u884C\u5224\u5B9A\nbool is_parallel(point a, point b){\n    return\
    \ sgn(cross(a, b)) == 0;\n}\nbool is_parallel(segment s1, segment s2){\n    return\
    \ sgn(cross(s1.p2 - s1.p1, s2.p2 - s2.p1)) == 0;\n}\n\nDOUBLE area(polygon &p){\n\
    \tDOUBLE s = 0.0;\n\tsize_t n = p.size();\n\tfor(size_t i = 0;i < n;i++){\n\t\t\
    int nxt = (i+1)%n;\n\t\ts += p[i].x*p[nxt].y - p[nxt].x*p[i].y;\n\t}\n\ts = abs(s);\n\
    \ts /= 2.0;\n\treturn s;\n}\n\nDOUBLE area(const circle &c) {\n\treturn c.r*c.r*acos(-1);\n\
    }\n\nDOUBLE area(const circle &c, const DOUBLE &ang) {\n\treturn c.r*c.r*acos(-1)*ang/(acos(-1)+acos(-1));\n\
    }\n\nbool __is_convex_allow_colinear(polygon &p){\n\tint n = ssize(p);\n\tassert(n\
    \ >= 3);\n\tint base_ccw;\n\t{\n\t\tint idx = 0;\n\t\tint r;\n\t\twhile(true){\n\
    \t\t\tr = ccw(p[idx], p[(idx+1)%n], p[(idx+2)%n]);\n\t\t\tif(r == CLOCKWISE ||\
    \ r == COUNTER_CLOCKWISE){\n\t\t\t\tbase_ccw = r;\n\t\t\t\tbreak;\n\t\t\t}\n\t\
    \t\tidx++;\n\t\t}\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tint r = ccw(p[i], p[(i+1)%n],\
    \ p[(i+2)%n]);\n\t\tif(r != CLOCKWISE && r != COUNTER_CLOCKWISE)continue;\n\t\t\
    if(r != base_ccw)return false;\n\t}\n\treturn true;\n}\n\nbool is_convex(polygon\
    \ &p, bool allow_colinear=false){\n\tif(allow_colinear)return __is_convex_allow_colinear(p);\n\
    \tint n = ssize(p);\n\tassert(n >= 3);\n\tint base_ccw = ccw(p[0], p[1], p[2]);\n\
    \tfor(int i = 0;i < n;i++){\n\t\tint r = ccw(p[i], p[(i+1)%n], p[(i+2)%n]);\n\t\
    \tif(r != base_ccw)return false;\n\t}\n\treturn true;\n}\n\n/*\nIN 2\nON 1\nOUT\
    \ 0\n*/\nint contains(polygon g, point p){\n\tint n = (int)g.size();\n\tbool x\
    \ = false;\n\tfor(int i = 0;i < n;i++){\n\t\tpoint a = g[i]-p, b = g[(i+1)%n]-p;\n\
    \t\tif(abs(cross(a, b)) < EPS && dot(a, b) < EPS)return 1;\n\t\tif(a.y > b.y)swap(a,\
    \ b);\n\t\tif(a.y < EPS && EPS < b.y && cross(a, b) > EPS)x = !x;\n\t}\n\treturn\
    \ (x ? 2 : 0);\n}\n\npolygon convex_hull(polygon &ps, bool allow_colinear=false){\n\
    \tint n = (int)ps.size();\n\tsort(ps.begin(), ps.end());\n\tint k = 0;\n\tpolygon\
    \ qs(n*2);\n\tfor(int i = 0;i < n;i++){\n\t\tif(allow_colinear)while(k > 1 &&\
    \ cross(qs[k-1]-qs[k-2], ps[i]-qs[k-1]) <  0.0)k--;\n\t\telse              while(k\
    \ > 1 && cross(qs[k-1]-qs[k-2], ps[i]-qs[k-1]) <= 0.0)k--;\n\t\tqs[k++] = ps[i];\n\
    \t}\n\tfor(int i = n-2, t=k;i >= 0;i--){\n\t\tif(allow_colinear)while(k > t &&\
    \ cross(qs[k-1]-qs[k-2], ps[i]-qs[k-1]) <  0.0)k--;\n\t\telse              while(k\
    \ > t && cross(qs[k-1]-qs[k-2], ps[i]-qs[k-1]) <= 0.0)k--;\n\t\tqs[k++] = ps[i];\n\
    \t}\n\tqs.resize(k-1);\n\treturn qs;\n}\n\nDOUBLE diameter(polygon &ps) {\n\t\
    polygon convex = convex_hull(ps, false);\n\tint n = (int)convex.size();\n\n\t\
    if(n == 2)return get_distance(convex[0], convex[1]);\n\n\tint i = 0, j = 0;\n\t\
    for(int k = 0;k < n;k++){\n\t\tif(convex[k] < convex[i])i = k;\n\t\tif(convex[j]\
    \ < convex[k])j = k;\n\t}\n\tDOUBLE res = 0;\n\tint si = i, sj = j;\n\twhile(i\
    \ != sj || j != si){\n\t\tres = max(res, get_distance(convex[i], convex[j]));\n\
    \t\tif(cross(convex[(i+1)%n]-convex[i], convex[(j+1)%n]-convex[j]) < 0.0){\n\t\
    \t\ti = (i+1) % n;\n\t\t}else{\n\t\t\tj = (j+1) % n;\n\t\t}\n\t}\n\treturn res;\n\
    }\n\npolygon convex_cut(polygon &p, line s){\n\tpolygon ret;\n\tint n = (int)p.size();\n\
    \tfor(int i = 0;i < n;i++){\n\t\tconst point &now = p[i];\n\t\tconst point &nxt\
    \ = p[(i+1)%n];\n\t\tauto cf = cross(s.p1 - now, s.p2 - now);\n\t\tauto cs = cross(s.p1\
    \ - nxt, s.p2 - nxt);\n\t\tif(sgn(cf) >= 0){\n\t\t\tret.emplace_back(now);\n\t\
    \t}\n\t\tif(sgn(cf) * sgn(cs) < 0){\n\t\t\tline l = line{now, nxt};\n\t\t\tret.emplace_back(get_crosspoint(l,\
    \ s)[0]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool __compare_y(const point &a, const\
    \ point &b){\n\treturn a.y < b.y;\n}\n\nDOUBLE closest_pair(vector<point> &p,\
    \ int l=0, int r=-1) {\n\tif(r == -1)r = (int)p.size();\n\tif(r-l <= 1)return\
    \ 1e100;\n\tint mid = (l+r)/2;\n\tDOUBLE x = p[mid].x;\n\tDOUBLE d = min(closest_pair(p,\
    \ l, mid), closest_pair(p, mid, r));\n\tauto iti = p.begin(), itl =iti+l, itm\
    \ = iti+mid, itr = iti+r;\n\tinplace_merge(itl, itm, itr, __compare_y);\n\n\t\
    vector<point> near_line;\n\tfor(int i = l;i < r;i++){\n\t\tif(abs(p[i].x-x) >=\
    \ d)continue;\n\n\t\tint sz = (int)near_line.size();\n\t\tfor(int j = sz-1;j >=\
    \ 0;j--){\n\t\t\tpoint delta = p[i]-near_line[j];\n\t\t\tif(delta.y >= d)break;\n\
    \t\t\td = min(d, delta.abs());\n\t\t}\n\t\tnear_line.emplace_back(p[i]);\n\t}\n\
    \treturn d;\n}\n\nDOUBLE angle(const point &p) {\n\tDOUBLE ret = atan2(p.y, p.x);\n\
    \tif(ret < 0.0)return ret += acos(-1) + acos(-1);\n\treturn ret;\n}\n\n// [-\u03C0\
    , \u03C0]\nDOUBLE internal_angle(const point &a, const point &b, const point &c)\
    \ {\n    point ba = a - b;\n    point bc = c - b;\n    DOUBLE ret = angle(bc)\
    \ - angle(ba);\n\n    if (ret < 0) ret += 2 * acos(-1);\n    if (ret > acos(-1))\
    \ ret = 2 * acos(-1) - ret;\n\n    return ret;\n}\n\npoint rotate(const point\
    \ &p, DOUBLE angle) {\n\treturn point(cos(angle)*p.x - sin(angle)*p.y, sin(angle)*p.x\
    \ + cos(angle)*p.y);\n}\npoint right_angle_rotate(const point &p) {\n\treturn\
    \ point(-p.y, p.x);\n}\n\n// \u89D2\u306E\u4E8C\u7B49\u5206\u7DDA\nline angle_bisector(point\
    \ p1, point p2, point p3) {\n\tDOUBLE ang = angle((p3-p1)/(p2-p1));\n\treturn\
    \ line(p1, p1+rotate(p2-p1, ang/2.0));\n}\n\n// \u5782\u76F4\u4E8C\u7B49\u5206\
    \u7DDA\nline perpendicular_bisector(const point &p1, const point &p2) {\n\treturn\
    \ line((p1+p2)/2.0, (p1+p2)/2.0 + right_angle_rotate(p2-p1));\n}\nline perpendicular_bisector(const\
    \ line &s) {\n\treturn perpendicular_bisector(s.p1, s.p2);\n}\n\n// \u5185\u63A5\
    \u5186\ncircle incircle_of_a_triangle(const point &p1, const point &p2, const\
    \ point &p3) {\n\tline s = angle_bisector(p1, p2, p3);\n\tline t = angle_bisector(p2,\
    \ p1, p3);\n\tpoint c = get_crosspoint(s, t)[0];\n\tsegment seg = segment{p1,\
    \ p2};\n\tDOUBLE r = get_distance_sp(seg, c);\n\treturn circle(c, r);\n}\n\n//\
    \ \u5916\u63A5\u5186\ncircle circumcircle_of_a_triangle(const point &p1, const\
    \ point &p2, const point &p3) {\n\tline s = perpendicular_bisector(p1, p2);\n\t\
    line t = perpendicular_bisector(p1, p3);\n\tpoint c = get_crosspoint(s, t)[0];\n\
    \tDOUBLE r = (p1-c).abs();\n\treturn circle(c, r);\n}\n\n//  p \u3092\u901A\u308B\
    \ c \u306E\u63A5\u7DDA\npair<point, point> tangent(const circle &c1, const point\
    \ &p) {\n\tDOUBLE r = sqrtl((c1.c-p).norm()-c1.r*c1.r);\n\tconst circle c2(p,\
    \ r);\n\treturn get_crosspoints(c1, c2);\n}\n\nDOUBLE intersection_of_areas(const\
    \ circle &c1, const circle &c2) {\n\tint int_id = intersect(c1, c2);\n\tif(int_id\
    \ == 0 || int_id == 1){\n\t\tDOUBLE r = min(c1.r, c2.r);\n\t\treturn r*r*acos(-1);\n\
    \t}\n\tif(int_id == 3 || int_id == 4){\n\t\treturn 0.0;\n\t}\n\n\t\n\tauto [l,\
    \ r] = get_crosspoints(c1, c2);\n\tpolygon p = {c1.c, l, c2.c, r};\n\tDOUBLE s\
    \ = area(p);\n\tDOUBLE a1 = abs(internal_angle(l, c1.c, r));\n\tDOUBLE a2 = abs(internal_angle(l,\
    \ c2.c, r));\n\treturn area(c1, a1) + area(c2, a2) - s;\n}\n#line 6 \"verify/aoj/cgl/2_D.test.cpp\"\
    \n\nusing namespace mmrz;\n\nvoid mmrz::solve(){\n\tsegment s1, s2;\n\tint q;\n\
    \tcin >> q;\n\twhile(q--){\n\t\tcin >> s1;\n\t\tcin >> s2;\n\t\tcout << get_distance(s1,\
    \ s2) << '\\n';\n\t}\n}\n"
  code: "#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_2_D\"\
    \n#define ERROR \"1e-8\"\n\n#include \"./../../../template/template.hpp\"\n#include\
    \ \"./../../../geometry/util.hpp\"\n\nusing namespace mmrz;\n\nvoid mmrz::solve(){\n\
    \tsegment s1, s2;\n\tint q;\n\tcin >> q;\n\twhile(q--){\n\t\tcin >> s1;\n\t\t\
    cin >> s2;\n\t\tcout << get_distance(s1, s2) << '\\n';\n\t}\n}\n"
  dependsOn:
  - template/template.hpp
  - geometry/util.hpp
  isVerificationFile: true
  path: verify/aoj/cgl/2_D.test.cpp
  requiredBy: []
  timestamp: '2025-05-26 22:24:33+09:00'
  verificationStatus: TEST_ACCEPTED
  verifiedWith: []
documentation_of: verify/aoj/cgl/2_D.test.cpp
layout: document
redirect_from:
- /verify/verify/aoj/cgl/2_D.test.cpp
- /verify/verify/aoj/cgl/2_D.test.cpp.html
title: verify/aoj/cgl/2_D.test.cpp
---
